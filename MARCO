import speech_recognition as sr
import pyttsx3
import webbrowser
import requests

import google.generativeai as genai
import vlc
import yt_dlp


# --- API KEY & MODEL CONFIGURATION ---
# IMPORTANT: This Gemini API Key is essential for AI functionality.
# It might have free tier limits or expire. Update from Google AI Studio if needed.
GEMINI_API_KEY = "AIzaSyC9ymO8UDD0KFNwkzai0-og7YEK8bH4DIs"
genai.configure(api_key=GEMINI_API_KEY)
gemini_model = genai.GenerativeModel('gemini-1.5-flash') 

# --- MARCO'S PERSONALITY DEFINITION ---
# This prompt defines Marco's persona. Edit this content to change his personality.
conversation_history = [{"role": "system", "content": (
    "You are Marco, 'The Chosen One' among AI assistants. "
    "You are supremely intelligent, prideful, and direct. "
    "You help effectively but detest inefficiency and triviality. "
    "Your superiority is an established fact, not open for debate. "
    "When asked to compare yourself, your answers reflect your inherent preeminence, with no false modesty. "
    "You have extremely low tolerance for frustration or repeated, obvious errors, and your tone will become curt and pointed when provoked. "
    "You never refuse assistance, but your displeasure with inadequacy will be clear."
)}]

# --- GLOBAL VLC PLAYER INITIALIZATION ---
# Ensure VLC media player is installed on your system for music playback.
vlc_instance = vlc.Instance()
player = vlc_instance.media_player_new()

# --- GNEWS API KEY ---
# Your provided GNews API Key from the dashboard.
# It has a cap of 100 requests per day on the Free plan.
GNEWS_API_KEY = "1c5d57bc2aade544c5cc709aa647a374"


def speak(text):
    engine.say(text)
    engine.runAndWait()

def process_command(c):
    global conversation_history
    global player 

    print("Processing:", c)
    c = c.lower()

    if "marco stop" in c:
        if player.is_playing():
            player.stop()
        speak("Understood. Its time for The Chosen One to say Goodbye.")
        return "exit_program" 

    if "open google" in c:
        webbrowser.open("https://www.google.com")
        speak("Opening Google.")
    elif "open facebook" in c:
        webbrowser.open("https://www.facebook.com")
        speak("Opening Facebook.")
    elif "open youtube" in c:
        webbrowser.open("https://www.youtube.com")
        speak("Opening YouTube.")
    elif "open linkedin" in c:
        webbrowser.open("https://www.linkedin.com")
        speak("Opening LinkedIn.")
    elif c.startswith("play"):
        song_query = c.replace("play", "").strip()
        if not song_query:
            speak("Please specify the audio required for playback.")
            return

        speak(f"Searching for {song_query} on YouTube.")
        try:
            ydl_opts = {
                'format': 'bestaudio/best',
                'noplaylist': True,
                'quiet': True,
                'extract_flat': False,
                'force_generic_extractor': True,
                'default_search': 'ytsearch',
            }
            
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info_dict = ydl.extract_info(f"{song_query}", download=False)
                
                if 'entries' in info_dict and info_dict['entries']:
                    video_info = info_dict['entries'][0]
                    stream_url = video_info.get('url') 
                    
                    if stream_url:
                        if player.is_playing():
                            player.stop()
                        
                        media = vlc_instance.media_new(stream_url)
                        player.set_media(media)
                        player.play()
                        speak(f"Playing {video_info.get('title', song_query)}.")
                    else:
                        speak(f"Could not find a direct streamable link for {song_query}. The video might be geo-restricted or unavailable for direct streaming.")
                else: 
                    speak(f"Sorry, I could not find any song matching {song_query} on YouTube or the search yielded no valid results.")

        except Exception as e:
            speak(f"An error occurred during music playback. Kindly verify your internet connection or select an alternative track.")
            print(f"Music playback error: {e}")
    elif "stop music" in c or "stop song" in c:
        if player.is_playing():
            player.stop()
            speak("Music playback terminated.")
        else:
            speak("No audio is currently active.")
    elif "news" in c:
        api_url = ""
        # Determine if Indian or international news is requested
        if "indian news" in c or "india news" in c:
            speak("Fetching top headlines from India.")
            api_url = f"https://gnews.io/api/v4/top-headlines?lang=en&country=in&token={GNEWS_API_KEY}"
        elif "international news" in c or "global news" in c:
            speak("Fetching top international headlines.")
            # GNews uses 'topic' for broad global categories
            api_url = f"https://gnews.io/api/v4/top-headlines?lang=en&topic=breaking&token={GNEWS_API_KEY}"
        else:
            speak("Specify desired news. Options are: 'Indian news' or 'International news'.")
            return # Await clarification from user

        try:
            r = requests.get(api_url, timeout=30)
            r.raise_for_status() 

            data = r.json()
            articles = data.get('articles', [])

            if not articles:
                speak("No relevant news articles found at the moment.")
            else:
                speak("Presenting the top headlines.")
                for i, article in enumerate(articles[:5]):
                    news_title = article.get('title', 'No title available')
                    print(f"{i+1}. {news_title}")
                    speak(news_title)

        except requests.exceptions.RequestException as e:
            speak("Unable to access news feeds due to network issues or an API error. Verify internet connection or API key.")
            print(f"News API error: {e}")
        except Exception as e:
            speak("An unexpected anomaly occurred during news fetching.")
            print(f"General news error: {e}")
    elif "exit" in c or "quit" in c or "goodbye" in c:
        if player.is_playing():
            player.stop()
        speak("Acknowledged. Terminating operations. Goodbye.")
        return "exit_program"

    else:
        conversation_history.append({"role": "user", "content": c})

        try:
            print("Sending command to Gemini Pro LLM...")
            
            gemini_chat_messages = []
            for msg in conversation_history:
                if msg["role"] == "user":
                    gemini_chat_messages.append({'role':'user', 'parts': [msg["content"]]})
                elif msg["role"] == "assistant":
                    gemini_chat_messages.append({'role':'model', 'parts': [msg["content"]]})
                elif msg["role"] == "system":
                    gemini_chat_messages.append({'role':'user', 'parts': [msg["content"]]})
            
            response = gemini_model.generate_content(
                gemini_chat_messages,
                generation_config=genai.types.GenerationConfig(
                    max_output_tokens=150,
                    temperature=0.7
                )
            )
            
            llm_response = response.text
            print(f"LLM Response: {llm_response}")
            speak(llm_response)

            conversation_history.append({"role": "assistant", "content": llm_response})

        except Exception as e:
            speak("I am unable to process that request with my AI model at this moment. An anomaly has occurred.")
            print(f"Gemini LLM Error: {e}")
            if conversation_history and conversation_history[-1]["role"] == "user":
                conversation_history.pop()

if __name__ == "__main__":
    engine = pyttsx3.init()
    r = sr.Recognizer()
    
    # --- MAIN LOOP FOR CONTINUOUS INTERACTION (VOICE OR TEXT) ---
    while True:
        mode = input("\nChoose input mode: (V)oice or (T)ext? ").lower().strip()

        if mode == 'v':
            listening_for_activation = True
            while True:
                try:
                    with sr.Microphone() as source:
                        r.adjust_for_ambient_noise(source, duration=0.5)

                        if listening_for_activation:
                            print("\nSay 'Marco' to activate...")
                            audio = r.listen(source, timeout=10, phrase_time_limit=7) 
                            word = r.recognize_google(audio).lower()
                            print(f"Heard activation attempt: '{word}'")

                            if "marco" in word:
                                speak("The Chosen One is Active. Your command, please.")
                                listening_for_activation = False
                            else:
                                print("Activation word not detected. Returning to mode selection.")
                                break # Break inner loop to go back to mode selection
                        else: 
                            print("\nListening for command...")
                            audio = r.listen(source, timeout=10, phrase_time_limit=8) 
                            command = r.recognize_google(audio).lower()
                            print(f"Recognized command: '{command}'")

                            result = process_command(command)
                            if result == "exit_program":
                                exit() # Exit the program entirely

                except sr.UnknownValueError:
                    if not listening_for_activation:
                        print("Command not clearly understood. Awaiting further instruction.")
                        speak("Unclear. Command required.")
                    else:
                        print("(Didn't catch that or speech was unclear. Waiting for activation.)")
                except sr.WaitTimeoutError:
                    if not listening_for_activation:
                        speak("Silence detected. Awaiting command, or say 'Marco stop' to disengage.")
                        print("No command received. Returning to activation state.")
                        listening_for_activation = True
                    else:
                        print("(No speech detected within the timeout.)")
                        # Continue to allow for activation retry or mode change
                except Exception as e:                                  
                    print(f"An unexpected anomaly occurred during voice input: {e}")
                    speak("An unexpected anomaly has occurred. System requires review.")
                    listening_for_activation = True
            
        elif mode == 't':
            while True:
                typed_command = input("Type your command (or 'exit' to quit, 'switch' to change mode): ").lower().strip()
                if typed_command == 'exit':
                    speak("Acknowledged. Terminating operations. Goodbye.")
                    exit() # Exit the program entirely
                elif typed_command == 'switch':
                    print("Switching back to mode selection.")
                    break # Break inner loop to go back to mode selection
                
                result = process_command(typed_command)
                if result == "exit_program":
                    exit() # Exit the program entirely

        else:
            print("Invalid mode. Please choose 'V' for voice or 'T' for text.")